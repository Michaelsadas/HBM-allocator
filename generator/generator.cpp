#include "generator.hpp"

Generator::Generator(string a, string b, int c){
    _type = a;
    _filename = b;
    _heap_depth = c;
	_bank = _total / _heap_depth;
}

void Generator::generate_allocator(){
    if(_type == "hta"){
        generate_hta();
    }else if(_type == "kwta"){
        generate_kwta();
    }else if(_type == "line"){
        generate_line();
    }
    else{
        cout << "Failed to generate the target allocator." << endl;
        return;
    }
    return;
}

void Generator::generate_line(){
    ofstream file;
    file.open(_filename);
    if(!file.is_open()){
		cout << "Cannot open the file." << endl;
        exit(EXIT_FAILURE);
    }

    file << "#include<cstdio>"<< endl;
    file << "#include<cstring>"<< endl;
    file << "#include<iostream>"<< endl;
    file << "#include<ap_int.h>"<< endl;
    file << "#include \"ap_utils.h\""<< endl;
    file << ""<< endl;
    file << "#define BANK "<< _bank << endl;
    file << "#define BANK_SHIFT "<< (int)log2(_bank) << endl;
	file << "#define N " << _heap_depth << endl;
    file << ""<< endl;
    file << "typedef struct{"<< endl;
    file << "    int free_target;"<< endl;
    file << "    int addr;"<< endl;
    file << "    int size;"<< endl;
    file << "    char cmd;"<< endl;
    file << "    char id;"<< endl;
    file << "} allocator_port;"<< endl;
    file << ""<< endl;
    file << "static int offsets[N] = {";
	for(int i = 0; i < _heap_depth - 1; i++){
		file << "0, ";
	}
	file << "0};" << endl;
    file << "static ap_uint <16> alloc_count[N] = {";
	for(int i = 0; i < _heap_depth - 1; i++){
		file << "0, ";
	}
	file << "0};" << endl;
    file << "static ap_uint<16> free_count[N] = {";
	for(int i = 0; i < _heap_depth - 1; i++){
		file << "0, ";
	}
	file << "0};" << endl;
    file << ""<< endl;
    file << "volatile void line_allocator(volatile allocator_port *alloc)"<< endl;
    file << "{"<< endl;
	file << "    #pragma HLS interface ap_hs port=alloc" << endl;
    file << "    ap_uint<32> free_target = 0, size = 0; //20 should be a parameter"<< endl;
    file << "    int loc;"<< endl;
    file << "    ap_uint<8> cmd = 0;"<< endl;
    file << "    ap_uint<8> id = 0;" << endl; 
	file << "	 ap_uint<8> i;" << endl;
	file << "    ap_uint<4> id_res;"<< endl;
    file << "    ap_uint<8> used_id;"<< endl;
    file << "	section0:{"<< endl;
    file << "#pragma HLS protocol fixed"<< endl;
    file << "		cmd = alloc->cmd;"<< endl;
    file << "		size = alloc->size;"<< endl;
    file << "		free_target = alloc->free_target;"<< endl;
    file << "		id= alloc->id;"<< endl;
    file << "	}"<< endl;
    file << "	if (cmd == 2){"<< endl;
    file << "		id_res = N;"<< endl;
    file << "		if(offsets[id] + size <= BANK){"<< endl;
    file << "			loc = offsets[id];"<< endl;
    file << "			id_res = id;"<< endl;
    file << "		}"<< endl;
    file << "		else{"<< endl;
    file << "			if(offsets[0] + size <= BANK) {id_res = 0;}"<< endl;
	for(int i = 1; i < _heap_depth; i++){
		file << "			else if(offsets[" << i << "] + size <= BANK) {id_res = " << i << ";}"<< endl;
	}
    // file << "			else if(offsets[1] + size <= BANK) {id_res = 1;}"<< endl;
    // file << "			else if(offsets[2] + size <= BANK) {id_res = 2;}"<< endl;
    // file << "			else if(offsets[3] + size <= BANK) {id_res = 3;}"<< endl;
	// file << "			for(i = 0; i < N; i ++){" << endl;
	// file << "				if(offsets[i] + size <= BANK){" << endl;
	// file << "					id_res = i;" << endl;
	// file << "					break;" << endl;
	// file << "				}" << endl;
	// file << "			}" << endl;
    file << "		}"<< endl;
    file << ""<< endl;
    file << "		if(id_res == N){"<< endl;
    file << "			#pragma HLS protocol fixed"<< endl;
    file << "			alloc->addr = -1;"<< endl;
    file << "		}"<< endl;
    file << "		else{"<< endl;
    file << "			section2:{"<< endl;
    file << "				#pragma HLS protocol fixed"<< endl;
    file << "				alloc->addr = offsets[id_res] + (id_res << BANK_SHIFT);"<< endl;
    file << "			}"<< endl;
    file << "			offsets[id_res] += size;"<< endl;
    file << "			alloc_count[id_res] ++;"<< endl;
    file << "		}"<< endl;
    file << "	}"<< endl;
    file << "	if (cmd == 3){"<< endl;
    file << "		id_res = free_target >> BANK_SHIFT;"<< endl;
    file << "		free_count[id_res] ++;"<< endl;
    file << "		if(free_count[id_res] == alloc_count[id_res]){"<< endl;
    file << "			free_count[id_res] = alloc_count[id_res] = 0;"<< endl;
    file << "			offsets[id_res] = 0;"<< endl;
    file << "		}"<< endl;
    file << "	}"<< endl;
    file << ""<< endl;
    file << "}"<< endl;
    file << ""<< endl;
    file << "int main(){"<< endl;
    file << "	return 0;"<< endl;
    file << "}"<< endl;
	file.close();
}

void Generator::generate_kwta(){
    ofstream file;
    file.open(_filename);
    if(!file.is_open()){
        exit(EXIT_FAILURE);
		cout << "Cannot open the file." << endl;
    }
    
    int total_branch;
    int trunk_size;
    int branch_size;
    int data_bias;

    total_branch = _heap_depth / _mini_heap_size;
    trunk_size = (int)pow(2, (int)log2(sqrt(total_branch)));
    branch_size = total_branch / trunk_size;
    data_bias = 33554432 / _heap_depth;

	file << "#include<cstdio>" << endl;
	file << "#include<cstring>" << endl;
	file << "#include<iostream>" << endl;
	file << "#include<ap_int.h>" << endl;
	file << "#include \"ap_utils.h\"" << endl;
	//file << "#include \"ktwa.h\"" << endl;
	file << "" << endl;
	file << "#define BRANCH " << branch_size << " //mini heap in one branch" << endl;
	file << "#define BRANCH_BIAS " << (int)log2(branch_size) << " //log2(BRANCH)" << endl;
	file << "#define TRUNK " << trunk_size << " //number of branches" << endl;
	file << "#define TRUNK_BIAS " << (int)log2(trunk_size) << " //log2(TRUNK)" << endl;
	file << "#define L " << trunk_size / 4 << " //number of branches in one HBM stack assuming there are 16 HBM ports" << endl;
	file << "#define B 4  //number of banks depending on HBM" << endl;
	file << "#define HEAP_BIAS " << (int)log2(_mini_heap_size) + 1 << " //number of log2(spaces in one mini heap) + 1" << endl;
	file << "#define DATA_BIAS " << (int)log2(data_bias) << " //the log2(size of one space)" << endl;
	file << "" << endl;
    file << "typedef struct{"<< endl;
    file << "    int free_target;"<< endl;
    file << "    int addr;"<< endl;
    file << "    int size;"<< endl;
    file << "    char cmd;"<< endl;
    file << "    char id;"<< endl;
    file << "} allocator_port;"<< endl;
    file << ""<< endl;
	file << "ap_uint<8> log_2_8bit(ap_uint<8> tmp)" << endl;
	file << "{" << endl;
	file << "//#pragma HLS INLINE" << endl;
	file << "	ap_uint<3> rc =0;" << endl;
	file << "	switch (tmp)" << endl;
	file << "	{" << endl;
	file << "		case 1: rc = 0;break;" << endl;
	file << "		case 2: rc = 1;break;" << endl;
	file << "		case 4: rc = 2;break;" << endl;
	file << "		case 8: rc = 3;break;" << endl;
	file << "		case 16: rc = 4;break;" << endl;
	file << "		case 32: rc = 5;break;" << endl;
	file << "		case 64: rc = 6;break;" << endl;
	file << "		case 128: rc = 7;break;" << endl;
	file << "	}" << endl;
	file << "	return rc;" << endl;
	file << "}" << endl;
	file << "" << endl;
	file << "static ap_uint<8> hash[37]={-1, 0, 1, 26, 2, 23, 27, -1, 3, 16, 24, 30, 28, 11, -1, 13, 4, 7, 17, -1, 25, 22, 31, 15, 29, 10, 12, 6, -1, 21, 14, 9, 5, 20, 8, 19, 18};" << endl;
	file << "const unsigned long long magic = 3134165325;" << endl;
	file << "ap_uint<8> log_2_32bit(ap_uint<32> tmp)" << endl;
	file << "{" << endl;
	file << "	ap_uint<32> rc = (((tmp * magic) >> 32) + tmp) >> 6;" << endl;
	file << "	return hash[tmp-((rc<<5)+(rc<<2)+rc)];" << endl;
	file << "}" << endl;
	file << "" << endl;
	file << "ap_uint<8> log_2_16bit(ap_uint<16> tmp)" << endl;
	file << "{" << endl;
	file << "#pragma HLS INLINE" << endl;
	file << "	ap_uint<16> rc =0;" << endl;
	file << "	switch (tmp)" << endl;
	file << "	{" << endl;
	file << "		case 1: rc = 0;break;" << endl;
	file << "		case 2: rc = 1;break;" << endl;
	file << "		case 4: rc = 2;break;" << endl;
	file << "		case 8: rc = 3;break;" << endl;
	file << "		case 16: rc = 4;break;" << endl;
	file << "		case 32: rc = 5;break;" << endl;
	file << "		case 64: rc = 6;break;" << endl;
	file << "		case 128: rc = 7;break;" << endl;
	file << "		case 256: rc = 8;break;" << endl;
	file << "		case 512: rc = 9;break;" << endl;
	file << "		case 1024: rc = 10;break;" << endl;
	file << "		case 2048: rc = 11;break;" << endl;
	file << "		case 4096: rc = 12;break;" << endl;
	file << "		case 8192: rc = 13;break;" << endl;
	file << "		case 16384: rc = 14;break;" << endl;
	file << "		case 32768: rc = 15;break;" << endl;
	file << "	}" << endl;
	file << "	return rc;" << endl;
	file << "}" << endl;
	file << "" << endl;
	file << "ap_uint<8> log_2_64bit(ap_uint<64> tmp)" << endl;
	file << "{" << endl;
	file << "	#pragma HLS INLINE off" << endl;
	file << "	ap_uint<16> AA,BB,CC,DD;" << endl;
	file << "	ap_uint<8> loc1;" << endl;
	file << "	AA=tmp(15,0);BB=tmp(31,16);CC=tmp(47,32);DD=tmp(63,48);" << endl;
	file << "	if (AA)loc1 = log_2_16bit(AA);" << endl;
	file << "	if (BB)loc1 = log_2_16bit(BB)+16;" << endl;
	file << "	if (CC)loc1 = log_2_16bit(CC)+32;" << endl;
	file << "	if (DD)loc1 = log_2_16bit(DD)+48;" << endl;
	file << "	return loc1;" << endl;
	file << "}" << endl;
	file << "" << endl;
	file << "ap_uint<16> log_2_256bit(ap_uint<256> tmp)" << endl;
	file << "{" << endl;
	file << "	#pragma HLS INLINE off" << endl;
	file << "	ap_uint<64> AA,BB,CC,DD;" << endl;
	file << "	ap_uint<16> loc1;" << endl;
	file << "	AA=tmp(63,0);BB=tmp(127,64);CC=tmp(191,128);DD=tmp(255,192);" << endl;
	file << "	if (AA)loc1 = log_2_16bit(AA);" << endl;
	file << "	if (BB)loc1 = log_2_16bit(BB)+64;" << endl;
	file << "	if (CC)loc1 = log_2_16bit(CC)+128;" << endl;
	file << "	if (DD)loc1 = log_2_16bit(DD)+192;" << endl;
	file << "	return loc1;" << endl;
	file << "}" << endl;
	file << "" << endl;
	file << "static ap_uint<BRANCH> heap_tree[TRUNK]={";
    for(int i = 0; i < trunk_size; i++){
        file << "-1, ";
        if(i % 16 == 15) file << "\n";
    }
	file << "};" << endl;
	file << "" << endl;
	file << "static ap_uint<TRUNK> top_heap=-1;" << endl;
	file << "static int last_offset[B]={-1, -1, -1, -1}; //20 should be a parameter" << endl;
	file << "static ap_uint<2 * HEAP_BIAS> used_free[" << total_branch << "]; //one for free and one for allocate" << endl;
	file << "static int last_loc1[B], last_loc2[B];" << endl;
	file << "static int last_addr[B];" << endl;
	file << "" << endl;
	file << "volatile void kwta_allocator(volatile allocator_port *alloc)" << endl;
	file << "{" << endl;
	file << "    #pragma HLS RESOURCE variable=heap_tree core=RAM_T2P_BRAM" << endl;
	file << "    #pragma HLS interface ap_hs port=alloc" << endl;
	file << "    #pragma HLS allocation instances=log_2_64bit limit=2 function" << endl;
	file << "" << endl;
	file << "    section0:{" << endl;
	file << "        #pragma HLS protocol fixed" << endl;
	file << "        ap_uint<32> free_target = 0; //20 should be a parameter" << endl;
	file << "        ap_uint<8> cmd = 0;" << endl;
	file << "        ap_uint<8> id = 0;" << endl;
	file << "        ap_uint<8> used_id;" << endl;
	file << "        int loc1 = 0, loc2 = 0; //20 should be a parameter" << endl;
	file << "        static ap_uint<HEAP_BIAS> cur_used = 0, cur_free = 0; //TODO" << endl;
	file << "        static ap_int<32> offset=-1;" << endl;
	file << "" << endl;
	file << "        section1:{" << endl;
	file << "            #pragma HLS protocol fixed" << endl;
	file << "            cmd = alloc->cmd;" << endl;
	file << "            free_target = alloc->free_target;" << endl;
	file << "            id = alloc->id;" << endl;
	file << "        }" << endl;
	file << "        if (cmd == 2)" << endl;
	file << "        {" << endl;
	file << "            #pragma HLS protocol fixed" << endl;
	file << "                " << endl;
	file << "            if(top_heap==0){" << endl;
	file << "                #pragma HLS protocol fixed" << endl;
	file << "                alloc->addr = -1;" << endl;
	file << "            }" << endl;
	file << "            else{" << endl;
	file << "                #pragma HLS protocol fixed" << endl;
	file << "                if(top_heap(id * L + L - 1, id * L) != 0) //if the target memory is available" << endl;
	file << "                {" << endl;
	file << "                    #pragma HLS protocol fixed" << endl;
	file << "                    used_id = id;" << endl;
	file << "                }" << endl;
	file << "                else // find another available memory" << endl;
	file << "                {" << endl;
	file << "                    if(top_heap(L - 1, 0) != 0) used_id = 0;" << endl;
	file << "                    if(top_heap(2 * L - 1, L) != 0) used_id = 1;" << endl;
	file << "                    if(top_heap(3 * L - 1, 2 * L) != 0) used_id = 2;" << endl;
	file << "                    if(top_heap(4 * L - 1, 3 * L) != 0) used_id = 3;" << endl;
	file << "                }" << endl;
	file << "" << endl;
	file << "                offset = last_offset[used_id];" << endl;
	file << "                loc1 = last_loc1[used_id];" << endl;
	file << "                loc2 = last_loc2[used_id];" << endl;
	file << "                if(offset(19,19) == 0)" << endl;
	file << "                {" << endl;
	file << "                    section5:{" << endl;
	file << "						#pragma HLS protocol fixed" << endl;
	file << "						alloc->addr = last_addr[used_id] << DATA_BIAS;   // if output_addr<0, it means the allocation turns out to be a failure." << endl;
	file << "					}" << endl;
	file << "                    last_addr[used_id] ++;" << endl;
	file << "                    cur_used = used_free[offset].range(2 * HEAP_BIAS - 1, HEAP_BIAS);" << endl;
	file << "                    used_free[offset].range(2 * HEAP_BIAS - 1, HEAP_BIAS) = cur_used + 1;" << endl;
	file << "                    if(cur_used == (1 << HEAP_BIAS) - 1){" << endl;
	file << "                        heap_tree[loc1].set(loc2, 0);" << endl;
	file << "                        last_offset[used_id] = -1;" << endl;
	file << "                        if(heap_tree[loc1] == 0){" << endl;
	file << "                            top_heap.set(loc1, 0);" << endl;
	file << "                        }" << endl;
	file << "                    }" << endl;
	file << "                }" << endl;
	file << "                else" << endl;
	file << "                {" << endl;
	if(trunk_size <= 16){
		file << "					last_loc1[used_id] = loc1 = log_2_16bit((ap_uint<16>)(top_heap(used_id * L + L - 1, used_id * L)-(top_heap(used_id * L + L - 1, used_id * L)&(top_heap(used_id * L + L - 1, used_id * L)-1)))) + used_id * L; //TODO" << endl;
	}else if(trunk_size <= 64){
		file << "					last_loc1[used_id] = loc1 = log_2_64bit((ap_uint<64>)(top_heap(used_id * L + L - 1, used_id * L)-(top_heap(used_id * L + L - 1, used_id * L)&(top_heap(used_id * L + L - 1, used_id * L)-1)))) + used_id * L; //TODO" << endl;
	}else{
		file << "					last_loc1[used_id] = loc1 = log_2_256bit((ap_uint<256>)(top_heap(used_id * L + L - 1, used_id * L)-(top_heap(used_id * L + L - 1, used_id * L)&(top_heap(used_id * L + L - 1, used_id * L)-1)))) + used_id * L; //TODO" << endl;
	}
	//file << "					last_loc1[used_id] = loc1 = log_2_64bit((ap_uint<64>)(top_heap(used_id * L + L - 1, used_id * L)-(top_heap(used_id * L + L - 1, used_id * L)&(top_heap(used_id * L + L - 1, used_id * L)-1)))) + used_id * L; //TODO" << endl;
	if(branch_size <= 16){
		file << "					last_loc2[used_id] = loc2 = log_2_16bit((ap_uint<16>)(heap_tree[loc1]-(heap_tree[loc1]&(heap_tree[loc1]-1)))); //TODO" << endl;
	}else if(trunk_size <= 64){
		file << "					last_loc2[used_id] = loc2 = log_2_64bit((ap_uint<64>)(heap_tree[loc1]-(heap_tree[loc1]&(heap_tree[loc1]-1)))); //TODO" << endl;
	}else{
		file << "					last_loc2[used_id] = loc2 = log_2_256bit((ap_uint<256>)(heap_tree[loc1]-(heap_tree[loc1]&(heap_tree[loc1]-1)))); //TODO" << endl;
	}	
	//file << "					last_loc2[used_id] = loc2 = log_2_64bit((ap_uint<64>)(heap_tree[loc1]-(heap_tree[loc1]&(heap_tree[loc1]-1)))); //TODO" << endl;
	file << "					last_offset[used_id] = offset = (loc1 << BRANCH_BIAS) + loc2;" << endl;
	file << "					used_free[offset].range(2 * HEAP_BIAS - 1, HEAP_BIAS) = 1;" << endl;
	file << "					last_addr[used_id] = (offset << HEAP_BIAS) + 1;" << endl;
	file << "                    section6:{" << endl;
	file << "                        #pragma HLS protocol fixed" << endl;
	file << "                        alloc->addr = (last_addr[used_id] - 1) << DATA_BIAS;" << endl;
	file << "                    }               " << endl;
	file << "                }" << endl;
	file << "            }" << endl;
	file << "        }" << endl;
	file << "" << endl;
	file << "        else if (cmd == 3)" << endl;
	file << "        {" << endl;
	file << "            int tmp_loc1, tmp_loc2, tmp_offset; //TODO" << endl;
	file << "            tmp_loc2 = free_target.range(BRANCH_BIAS + DATA_BIAS + HEAP_BIAS - 1, DATA_BIAS + HEAP_BIAS);" << endl;
	file << "            tmp_loc1 = free_target.range(TRUNK_BIAS + BRANCH_BIAS + DATA_BIAS + HEAP_BIAS - 1, BRANCH_BIAS + DATA_BIAS + HEAP_BIAS);" << endl;
	file << "            tmp_offset = free_target.range(TRUNK_BIAS + BRANCH_BIAS + DATA_BIAS + HEAP_BIAS - 1, DATA_BIAS + HEAP_BIAS);" << endl;
	file << "            cur_free = used_free[tmp_offset].range(HEAP_BIAS - 1,0) + 1;" << endl;
	file << "            if(cur_free == (1 << HEAP_BIAS))" << endl;
	file << "            {" << endl;
	file << "				heap_tree[tmp_loc1].set(tmp_loc2,1);" << endl;
	file << "				top_heap.set(tmp_loc1,1);" << endl;
	file << "				used_free[tmp_offset]= 0;                " << endl;
	file << "            }" << endl;
	file << "            else " << endl;
	file << "                used_free[tmp_offset].range(HEAP_BIAS - 1,0) = cur_free;" << endl;
	file << "        }" << endl;
	file << "" << endl;
	file << "        else" << endl;
	file << "        {" << endl;
	file << "			io_section6:{" << endl;
	file << "		    	#pragma HLS protocol fixed" << endl;
	file << "			    alloc->addr = -1;" << endl;
	file << "			}            " << endl;
	file << "        }" << endl;
	file << "    }" << endl;
	file << "" << endl;
	file << "}" << endl;
	file << "" << endl;
    file << "int main(){"<< endl;
    file << "	return 0;"<< endl;
    file << "}"<< endl;
	file.close();
}

void Generator::generate_hta(){
	ofstream file;
    file.open(_filename);
    if(!file.is_open()){
        exit(EXIT_FAILURE);
		cout << "Cannot open the file." << endl;
    }

	int layers = (int)log2(_heap_depth);
	int mau_size =  _total / _heap_depth;
	int shift = log2(mau_size);
	int tree_shift = 16 - layers;
	int branch_size = _heap_depth / 64 * 2;

	file << "#include<cstdio>" << endl;
	file << "#include<cstring>" << endl;
	file << "#include<iostream>" << endl;
	file << "#include<ap_int.h>" << endl;
	file << "#include \"ap_utils.h\"" << endl;
	file << "#include \"hta.h\"" << endl;
	file << "" << endl;
	file << "#define N " << _heap_depth << endl;
	file << "#define LAYERS " << layers << endl;
	file << "#define MAU_SIZE " << mau_size << endl;
	file << "#define SHIFT " << shift << endl;
	file << "#define TREE_SHIFT " << tree_shift << " // 16 - log2(N)" << endl;
	file << "#define BRANCH_SIZE " << branch_size << endl;
	file << "#define branch_level 64" << endl;
	file << "" << endl;
	file << "typedef struct{" << endl;
	file << "int size;" << endl;
	file << "int addr;" << endl;
	file << "int free_target;" << endl;
	file << "char id;" << endl;
	file << "char cmd;" << endl;
	file << "} allocator_port;" << endl;
	file << "" << endl;
	// file << "ap_uint<8> log_2_8bit(ap_uint<8> tmp)" << endl;
	// file << "{" << endl;
	// file << "	#pragma HLS INLINE" << endl;
	// file << "	ap_uint<3> rc =0;" << endl;
	// file << "	switch (tmp)" << endl;
	// file << "	{" << endl;
	// file << "		case 1: rc = 0;break;" << endl;
	// file << "		case 2: rc = 1;break;" << endl;
	// file << "		case 4: rc = 2;break;" << endl;
	// file << "		case 8: rc = 3;break;" << endl;
	// file << "		case 16: rc = 4;break;" << endl;
	// file << "		case 32: rc = 5;break;" << endl;
	// file << "		case 64: rc = 6;break;" << endl;
	// file << "		case 128: rc = 7;break;" << endl;
	// file << "	}" << endl;
	// file << "	return rc;" << endl;
	// file << "}" << endl;
	// file << "static ap_uint<8> hash[37]={-1, 0, 1, 26, 2, 23, 27, -1, 3, 16, 24, 30, 28, 11, -1, 13, 4, 7, 17, -1, 25, 22, 31, 15, 29, 10, 12, 6, -1, 21, 14, 9, 5, 20, 8, 19, 18};" << endl;
	// file << "const unsigned long long magic = 3134165325;" << endl;
	// file << "ap_uint<8> log_2_32bit(ap_uint<32> tmp)" << endl;
	// file << "{" << endl;
	// file << "	ap_uint<32> rc = (((tmp * magic) >> 32) + tmp) >> 6;" << endl;
	// file << "	return hash[tmp-((rc<<5)+(rc<<2)+rc)];" << endl;
	// file << "}" << endl;
	// file << "ap_uint<8> log_2_16bit(ap_uint<16> tmp)" << endl;
	// file << "{" << endl;
	// file << "	#pragma HLS INLINE" << endl;
	// file << "	ap_uint<8> rc =0;" << endl;
	// file << "	switch (tmp)" << endl;
	// file << "	{" << endl;
	// file << "		case 1: rc = 0;break;" << endl;
	// file << "		case 2: rc = 1;break;" << endl;
	// file << "		case 4: rc = 2;break;" << endl;
	// file << "		case 8: rc = 3;break;" << endl;
	// file << "		case 16: rc = 4;break;" << endl;
	// file << "		case 32: rc = 5;break;" << endl;
	// file << "		case 64: rc = 6;break;" << endl;
	// file << "		case 128: rc = 7;break;" << endl;
	// file << "		case 256: rc = 8;break;" << endl;
	// file << "		case 512: rc = 9;break;" << endl;
	// file << "		case 1024: rc = 10;break;" << endl;
	// file << "		case 2048: rc = 11;break;" << endl;
	// file << "		case 4096: rc = 12;break;" << endl;
	// file << "		case 8192: rc = 13;break;" << endl;
	// file << "		case 16384: rc = 14;break;" << endl;
	// file << "		case 32768: rc = 15;break;" << endl;
	// file << "	}" << endl;
	// file << "	return rc;" << endl;
	// file << "}" << endl;
	// file << "" << endl;
	// file << "ap_uint<8> log_2_64bit(ap_uint<64> tmp)" << endl;
	// file << "{" << endl;
	// file << "	#pragma HLS INLINE off" << endl;
	// file << "	ap_uint<16> AA,BB,CC,DD;" << endl;
	// file << "	ap_uint<8> loc1;" << endl;
	// file << "	AA=tmp(15,0);BB=tmp(31,16);CC=tmp(47,32);DD=tmp(63,48);" << endl;
	// file << "	if (AA)loc1 = log_2_16bit(AA);" << endl;
	// file << "	if (BB)loc1 = log_2_16bit(BB)+16;" << endl;
	// file << "	if (CC)loc1 = log_2_16bit(CC)+32;" << endl;
	// file << "	if (DD)loc1 = log_2_16bit(DD)+48;" << endl;
	// file << "	return loc1;" << endl;
	// file << "}" << endl;
	// file << "" << endl;
	// file << "ap_uint<16> log_2_256bit(ap_uint<256> tmp)" << endl;
	// file << "{" << endl;
	// file << "	#pragma HLS INLINE off" << endl;
	// file << "	ap_uint<64> AA,BB,CC,DD;" << endl;
	// file << "	ap_uint<16> loc1;" << endl;
	// file << "	AA=tmp(63,0);BB=tmp(127,64);CC=tmp(191,128);DD=tmp(255,192);" << endl;
	// file << "	if (AA)loc1 = log_2_16bit(AA);" << endl;
	// file << "	if (BB)loc1 = log_2_16bit(BB)+64;" << endl;
	// file << "	if (CC)loc1 = log_2_16bit(CC)+128;" << endl;
	// file << "	if (DD)loc1 = log_2_16bit(DD)+192;" << endl;
	// file << "	return loc1;" << endl;
	// file << "}" << endl;
	// file << "" << endl;
	// file << "ap_uint<16> log_2_512bit(ap_uint<512> tmp)" << endl;
	// file << "{" << endl;
	// file << "	#pragma HLS INLINE off" << endl;
	// file << "	ap_uint<64> AA,BB,CC,DD,EE,FF,GG,HH;" << endl;
	// file << "	ap_uint<16> loc1;" << endl;
	// file << "	AA=tmp(63,0);BB=tmp(127,64);CC=tmp(191,128);DD=tmp(255,192);" << endl;
	// file << "	EE=tmp(63,0);FF=tmp(127,64);GG=tmp(191,128);HH=tmp(255,192);" << endl;
	// file << "	if (AA)loc1 = log_2_16bit(AA);" << endl;
	// file << "	if (BB)loc1 = log_2_16bit(BB)+64;" << endl;
	// file << "	if (CC)loc1 = log_2_16bit(CC)+128;" << endl;
	// file << "	if (DD)loc1 = log_2_16bit(DD)+192;" << endl;
	// file << "	if (EE)loc1 = log_2_16bit(EE)+256;" << endl;
	// file << "	if (FF)loc1 = log_2_16bit(FF)+320;" << endl;
	// file << "	if (GG)loc1 = log_2_16bit(GG)+384;" << endl;
	// file << "	if (HH)loc1 = log_2_16bit(HH)+448;" << endl;
	// file << "	return loc1;" << endl;
	// file << "}" << endl;
	// file << "" << endl;
	file << "//the top layer of the tree is regards as layer 0" << endl;
	file << "static ap_uint<64> buddy_tree[17] = {0x1, 0x3, 0xF, 0xFF, 0xFFFF, 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};" << endl;
	file << "static ap_uint<BRANCH_SIZE> branch_tree[64]={";
	for(int i = 0; i < 64; i++){
		file << "-1, ";
		if(i % 16 == 15) file << endl;
	}
	file << "};" << endl;
	file << "" << endl;
	file << "static ap_uint<64> buddy_mask[64] ={0,	0,	0x1,	0x3,	0xf,	0xff,	0xffff,	0xffff,	0xffff,	0xffff,	0xffff,	0xffff,	0xffff,	0xffff,	0xffff,	0xffff,	" << endl;
	file << "0,	0,	0x2,	0xc,	0xf0,	0xff00,	0xffff0000,	0xffff0000,	0xffff0000,	0xffff0000,	0xffff0000,	0xffff0000,	0xffff0000,	0xffff0000,	0xffff0000,	0xffff0000,	" << endl;
	file << "0,	0,	0x4,	0x30,	0xf00,	0xff0000,	0xffff00000000,	0xffff00000000,	0xffff00000000,	0xffff00000000,	0xffff00000000,	0xffff00000000,	0xffff00000000,	0xffff00000000,	0xffff00000000,	0xffff00000000,	" << endl;
	file << "0,	0,	0x8,	0xc0,	0xf000,	0xff000000,	0xffff000000000000,	0xffff000000000000,	0xffff000000000000,	0xffff000000000000,	0xffff000000000000,	0xffff000000000000,	0xffff000000000000,	0xffff000000000000,	0xffff000000000000,	0xffff000000000000};//64 = 4 * 16" << endl;
	file << "static ap_uint<64> mask[10]={1,3, 0xF, 0xFF, 0xFFFF, 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFFFFFFFFFF,0,0};" << endl;
	file << "static ap_uint<BRANCH_SIZE> mask_mask[16];" << endl;
	file << "static ap_uint<BRANCH_SIZE> full = -1;" << endl;
	file << "" << endl;
	file << "static ap_uint<BRANCH_SIZE> branch_mask[16];" << endl;
	file << "" << endl;
	file << "static ap_uint<16> loc_shift[17] = {0,	0,	0,	0,	0,	0,	0,	1,	3,	7, 15, 31, 63, 127, 255, 511, 1023};" << endl;
	file << "" << endl;
	file << "static ap_uint<8> addr_layer_map[N];//HTA1024" << endl;
	file << "" << endl;
	file << "volatile void hta_allocator(volatile allocator_port *alloc)//, volatile ap_uint<64> // *port1, volatile ap_uint<64> // *port2)" << endl;
	file << "{" << endl;
	file << "#pragma HLS ARRAY_PARTITION variable=branch_tree cyclic factor=2 dim=1" << endl;
	file << "#pragma HLS ARRAY_PARTITION variable=buddy_tree cyclic factor=2 dim=1" << endl;
	file << "#pragma HLS interface ap_hs port=alloc" << endl;
	file << "" << endl;
	file << "#pragma HLS allocation instances=log_2_64bit limit=1 function" << endl;
	file << "{" << endl;
	file << "	#pragma HLS protocol fixed" << endl;
	file << "	static bool a = true;" << endl;
	file << "	if(a){" << endl;
	for(int i = 7; i <= layers; i++){
		file << "		branch_mask[" << i << "] = (full << " << (int)pow(2, i - 6) - 1 << ") & (full >> " << branch_size - (int)pow(2, i - 5) + 1 << "); " << endl;
	}
	// file << "		branch_mask[7] = (full << 1) & (full >> 125); " << endl;
	// file << "		branch_mask[8] = (full << 3) & (full >> 121);" << endl;
	// file << "		branch_mask[9] = (full << 7) & (full >> 113);" << endl;
	// file << "		branch_mask[10] = (full << 15) & (full >> 94);" << endl;
	// file << "		branch_mask[11] = (full << 31) & (full >> 65);" << endl;
	// file << "		branch_mask[12] = (full << 63) & (full >> 1);" << endl;
	for(int i = 1; i <= layers - 6; i++){
		file << "		mask_mask[" << i << "] = full >> " << branch_size - (int)pow(2, i) << ";" << endl;
	}
	// file << "		mask_mask[1] = full >> 126;" << endl;
	// file << "		mask_mask[2] = full >> 122;" << endl;
	// file << "		mask_mask[3] = full >> 120;" << endl;
	// file << "		mask_mask[4] = full >> 112;" << endl;
	// file << "		mask_mask[5] = full >> 96;" << endl;
	// file << "		mask_mask[6] = full >> 64;" << endl;
	file << "		a = false;" << endl;
	file << "	}" << endl;
	file << "" << endl;
	file << "	ap_wait();" << endl;
	file << "	volatile int status = 0;" << endl;
	file << "	int size = 0;" << endl;
	file << "	ap_uint<16> tmp_size = 0, inv_size = 0;" << endl;
	file << "	ap_uint<32> free_target = 0;" << endl;
	file << "	int output_addr = 0;" << endl;
	file << "	ap_uint<5> id = 0, cnt = 0;" << endl;
	file << "	ap_uint<16> loc1 = 0, loc2 = 0;" << endl;
	file << "	ap_uint<16> new_loc_s1 = 0, new_loc_s2 = 0, new_loc_f = 0, new_loc_g = 0;" << endl;
	file << "	ap_uint<64> TMP_0 = 0;" << endl;
	file << "	ap_uint<" << branch_size << "> TMP_1 = 0;" << endl;
	file << "	ap_uint<5> ans, ans_f, ans_s, ans_g;" << endl;
	file << "	bool sets;" << endl;
	file << "" << endl;
	file << "	volatile int cmd = 0;" << endl;
	file << "	io_section1:{" << endl;
	file << "		#pragma HLS protocol fixed" << endl;
	file << "		cmd = alloc->cmd;" << endl;
	file << "		size = alloc->size;" << endl;
	file << "		id = alloc->id;" << endl;
	file << "		free_target = alloc->free_target;" << endl;
	file << "		tmp_size = (size >> SHIFT) - 1;" << endl;
	file << "		inv_size = tmp_size.reverse();" << endl;
	file << "	}" << endl;
	file << "" << endl;
	file << "	ans = 0;" << endl;
	file << "	if(cmd == 2)" << endl;
	file << "	{" << endl;
	file << "		#pragma HLS protocol fixed" << endl;
	file << "		if(size <= MAU_SIZE) {" << endl;
	file << "			ans = LAYERS - 1;" << endl;
	file << "		}" << endl;
	file << "		else{" << endl;
	file << "			TMP_0 = inv_size & (~(inv_size - 1));" << endl;
	file << "			ans = log_2_64bit(TMP_0) - TREE_SHIFT;" << endl;
	file << "		}" << endl;
	file << "" << endl;
	file << "		ans_s = (ans > 6) ? (ap_uint<5>)6 : ans;" << endl;
	file << "" << endl;
	file << "		if(ans <= 1){" << endl;
	file << "			TMP_0 = buddy_tree[ans] & (~(buddy_tree[ans] - 1));" << endl;
	file << "			loc1 = log_2_64bit(TMP_0);" << endl;
	file << "		}" << endl;
	file << "		else if((TMP_0 = buddy_tree[ans] & buddy_mask[id * 16 + ans_s]) != 0){" << endl;
	file << "			TMP_0 = TMP_0 & (~(TMP_0 - 1));" << endl;
	file << "			loc1 = log_2_64bit(TMP_0);" << endl;
	file << "		}" << endl;
	file << "		else{" << endl;
	file << "			TMP_0 = buddy_tree[ans] & (~(buddy_tree[ans] - 1));" << endl;
	file << "			loc1 = log_2_64bit(TMP_0);" << endl;
	file << "		}" << endl;
	file << "" << endl;
	file << "		if(TMP_0){" << endl;
	file << "			if(ans <= 6){" << endl;
	file << "				output_addr = loc1 << (LAYERS - ans);" << endl;
	file << "				alloc->addr = output_addr << SHIFT;" << endl;
	file << "				buddy_tree[ans].set(loc1, 0);" << endl;
	file << "			}" << endl;
	file << "			else{" << endl;
	file << "				TMP_1 = branch_tree[loc1] & branch_mask[ans];" << endl;
	file << "				TMP_1 = TMP_1&(~(TMP_1-1));" << endl;
	// if(branch_size / 2 <= 16){
	// 	file << "				loc2 = log_2_16bit(TMP_1);" << endl;
	// }
	// if(branch_size / 2 <= 64){
	// 	file << "				loc2 = log_2_64bit(TMP_1);" << endl;
	// }else if (branch_size / 2 <= 256){
	// 	file << "				loc2 = log_2_256bit(TMP_1);" << endl;
	// }else{
	// 	file << "				loc2 = log_2_512bit(TMP_1);" << endl;
	// }
	file << "				loc2 = log_2_" << branch_size << "bit(TMP_1);" << endl;
	file << "				output_addr = (loc1 << (LAYERS - 6)) + ((loc2 - loc_shift[ans])<< (LAYERS - ans));" << endl;
	file << "				alloc->addr = output_addr << SHIFT;" << endl;
	file << "				buddy_tree[6].set(loc1, 0);" << endl;
	file << "				branch_tree[loc1].set(loc2, 0);" << endl;
	file << "			}" << endl;
	file << "			addr_layer_map[output_addr] = ans;" << endl;
	file << "" << endl;
	file << "			//maintainance" << endl;
	file << "			if(ans <= 6){" << endl;
	file << "				TMP_0 = ~(mask[0] << loc1);" << endl;
	file << "				loc2 = loc1 << 1;" << endl;
	file << "				loc1 >>= 1;" << endl;
	file << "				cnt = 1;" << endl;
	file << "				buddy_tree[0] = 0;" << endl;
	file << "				for(ans_f= ans+(ans==0)-1, ans_s=ans+1; (ans_f >= 1)||(ans_s <= 6); ans_f-=(ans_f!=0), ans_s+=(ans_s!=7)){" << endl;
	file << "					#pragma HLS dependence variable=buddy_tree intra false" << endl;
	file << "					#pragma HLS pipeline" << endl;
	file << "					if(ans_f >= 1){" << endl;
	file << "						buddy_tree[ans_f].set(loc1, 0);" << endl;
	file << "						loc1 >>= 1;" << endl;
	file << "					}" << endl;
	file << "					if(ans_s <= 6){" << endl;
	file << "						TMP_0 = ~(mask[cnt] << loc2); //TODO" << endl;
	file << "						buddy_tree[ans_s] = buddy_tree[ans_s] & TMP_0;" << endl;
	file << "						loc2 <<= 1;" << endl;
	file << "						cnt ++;" << endl;
	file << "					}" << endl;
	file << "				}" << endl;
	file << "				//TMP_1 = TMP_0;" << endl;
	file << "				for(ans_s = 7; ans_s <=LAYERS; ans_s ++){" << endl;
	file << "					#pragma HLS dependence variable=buddy_tree intra false" << endl;
	file << "					#pragma HLS pipeline" << endl;
	file << "					buddy_tree[ans_s] &= TMP_0;" << endl;
	file << "				}" << endl;
	file << "			}" << endl;
	file << "			else{" << endl;
	file << "				new_loc_g = loc1 >> 1;" << endl;
	file << "				cnt = 1;" << endl;
	file << "				new_loc_f = (loc2 - 1) >> 1;" << endl;
	file << "				new_loc_s1 = (loc2 << 1) + 1;" << endl;
	file << "				//new_loc_s2 = (loc2 << 1) + 2;" << endl;
	file << "				buddy_tree[0] = 0;" << endl;
	file << "				for(ans_g = 5, ans_f = ans - 1, ans_s = ans + 1; (ans_g >= 1) || (ans_f >= 7) || (ans_s <= LAYERS); ans_g -= (ans_g != 0), ans_f -= (ans_f != 6), ans_s += (ans_s != LAYERS + 1))" << endl;
	file << "				{" << endl;
	file << "					#pragma HLS dependence variable=buddy_tree intra false" << endl;
	file << "					#pragma HLS pipeline" << endl;
	file << "" << endl;
	file << "					if(ans_g >= 1){" << endl;
	file << "						buddy_tree[ans_g].set(new_loc_g, 0);" << endl;
	file << "						new_loc_g = new_loc_g >> 1;" << endl;
	file << "					}" << endl;
	file << "					if(ans_f >= 7){" << endl;
	file << "						branch_tree[loc1].set(new_loc_f, 0);" << endl;
	file << "						buddy_tree[ans_f].set(loc1, (branch_tree[loc1] & branch_mask[ans] != 0));" << endl;
	file << "						new_loc_f = (new_loc_f - 1) >> 1;" << endl;
	file << "					}					" << endl;
	file << "					if(ans_s <= LAYERS){" << endl;
	file << "						branch_tree[loc1] = branch_tree[loc1] & (~(mask_mask[cnt] << new_loc_s1));" << endl;
	file << "						buddy_tree[ans_s].set(loc1, (branch_tree[loc1] & branch_mask[ans] != 0));" << endl;
	file << "						new_loc_s1 = (new_loc_s1 << 1) + 1;" << endl;
	file << "						cnt ++;" << endl;
	file << "					}" << endl;
	file << "				}" << endl;
	file << "			}" << endl;
	file << "		}" << endl;
	file << "		else{" << endl;
	file << "			alloc->addr = -1;" << endl;
	file << "			return;" << endl;
	file << "		}" << endl;
	file << "	}" << endl;
	file << "	if(cmd == 3){" << endl;
	file << "		free_target = free_target >> SHIFT;" << endl;
	file << "		ans = addr_layer_map[free_target];" << endl;
	file << "		if(ans <= 6){" << endl;
	file << "			TMP_0 = (mask[0] << loc1);" << endl;
	file << "			loc1 = free_target.range(LAYERS - 1, LAYERS - ans);" << endl;
	file << "			buddy_tree[ans].set(loc1, 1);" << endl;
	file << "			new_loc_f = loc1 >> 1;" << endl;
	file << "			new_loc_s1 = loc1 << 1;" << endl;
	file << "			cnt = 1;" << endl;
	file << "			for(ans_f= ans+(ans==0)-1, ans_s = ans + 1; (ans_f >= 1) || (ans_s <= 6); ans_f -= (ans_f != 0), ans_s += (ans_s != 7)){" << endl;
	file << "				#pragma HLS dependence variable=buddy_tree intra false" << endl;
	file << "				#pragma HLS pipeline" << endl;
	file << "				if(ans_f >= 1){" << endl;
	file << "					buddy_tree[ans_f].set(new_loc_f, buddy_tree[ans_f + 1]((new_loc_f << 1) + 1, (new_loc_f << 1) + 1) && buddy_tree[ans_f + 1](new_loc_f << 1, new_loc_f << 1));" << endl;
	file << "					new_loc_f = new_loc_f >> 1;" << endl;
	file << "				}" << endl;
	file << "				if(ans_s <= 6){" << endl;
	file << "					TMP_0 = (mask[cnt] << new_loc_s1);" << endl;
	file << "					buddy_tree[ans_s] = buddy_tree[ans_s] | TMP_0;" << endl;
	file << "					new_loc_s1 = (new_loc_s1 << 1);" << endl;
	file << "					cnt ++;" << endl;
	file << "				}" << endl;
	file << "			}" << endl;
	file << "			//TMP_1 = TMP_0;" << endl;
	file << "			for(ans_s = 7; ans_s <=LAYERS; ans_s ++){" << endl;
	file << "				#pragma HLS dependence variable=buddy_tree intra false" << endl;
	file << "				#pragma HLS pipeline" << endl;
	file << "				buddy_tree[ans_s] |= TMP_0;" << endl;
	file << "			}" << endl;
	file << "		}" << endl;
	file << "		else{" << endl;
	file << "			loc2 = free_target.range(LAYERS - 7, LAYERS - ans) + loc_shift[ans]; //index in the branch" << endl;
	file << "			loc1 = free_target.range(LAYERS - 1, LAYERS - 6);//index in the buddy" << endl;
	file << "			branch_tree[loc1].set(loc2, 1);" << endl;
	file << "			buddy_tree[ans].set(loc1, 1);" << endl;
	file << "			new_loc_f = (loc2 - 1) >> 1;" << endl;
	file << "			new_loc_s1 = (loc2 << 1) + 1;" << endl;
	file << "			cnt = 1;" << endl;
	file << "			for(ans_f = ans - 1, ans_s = ans + 1; (ans_f >= 7) || (ans_s <= LAYERS); ans_f -= (ans_f != 6), ans_s += (ans_s != LAYERS + 1)){" << endl;
	file << "				#pragma HLS dependence variable=buddy_tree intra false" << endl;
	file << "				#pragma HLS pipeline" << endl;
	file << "				if(ans_f >= 7){" << endl;
	file << "					sets = branch_tree[loc1]((new_loc_f << 1) + 2, (new_loc_f << 1) + 2) && branch_tree[loc1]((new_loc_f << 1) + 1, (new_loc_f << 1) + 1);" << endl;
	file << "					branch_tree[loc1].set(new_loc_f, sets);" << endl;
	file << "					buddy_tree[ans_f].set(loc1, sets);" << endl;
	file << "					new_loc_f = (new_loc_f - 1) >> 1;" << endl;
	file << "				}" << endl;
	file << "				if(ans_s <= LAYERS){" << endl;
	file << "					branch_tree[loc1] = branch_tree[loc1] | (mask_mask[cnt] << new_loc_s1);" << endl;
	file << "					new_loc_s1 = new_loc_s1 << 1;" << endl;
	file << "				}				" << endl;
	file << "			}" << endl;
	file << "			if(branch_tree[loc1](2, 2) && branch_tree[loc1](1, 1)){" << endl;
	file << "				branch_tree[loc1].set(0, 1);" << endl;
	file << "				buddy_tree[6].set(loc1, 1);" << endl;
	file << "				new_loc_f = loc1 >> 1;" << endl;
	file << "				for(ans_g = 5; ans_g > 0; ans_g -= (ans_g != 0)){" << endl;
	file << "					#pragma HLS dependence variable=buddy_tree intra false" << endl;
	file << "					#pragma HLS pipeline" << endl;
	file << "					buddy_tree[ans_g].set(new_loc_f, buddy_tree[ans_g + 1]((new_loc_f << 1) + 1, (new_loc_f << 1) + 1) && buddy_tree[ans_g + 1]((new_loc_f << 1), (new_loc_f << 1)));" << endl;
	file << "					new_loc_f = new_loc_f >> 1;" << endl;
	file << "				}" << endl;
	file << "			}" << endl;
	file << "			buddy_tree[0] = (buddy_tree[1]==3);" << endl;
	file << "		}" << endl;
	file << "		" << endl;
	file << "	}" << endl;
	file << "}" << endl;
	file << "}" << endl;
	file.close();
}